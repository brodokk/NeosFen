from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import PureWindowsPath
from typing import List, Optional

from neos.secrets import generate
from neos.exceptions import NeosException

from urllib.parse import ParseResult


class RecordType(Enum):
    OBJECT = "object"
    LINK = "link"
    DIRECTORY = "directory"
    WORLD = "world"
    TEXTURE = "texture"
    AUDIO = "audio"


@dataclass
class NeosRecord:
    id: str
    globalVersion: int
    localVersion: int
    lastModifyingUserId: Optional[str]
    name: str
    recordType: RecordType
    path: Optional[str]
    isPublic: bool
    isForPatrons: bool
    isListed: bool
    isDeleted: bool
    lastModificationTime: datetime
    visits: int
    rating: int
    ownerId: str


@dataclass
class NeosLink(NeosRecord):
    assetUri: ParseResult


@dataclass
class NeosDirectory(NeosRecord):
    lastModifyingMachineId: Optional[str]
    ownerName: str
    tags: List[str]
    creationTime: Optional[datetime]

    @property
    def content_path(self) -> str:
        return str(PureWindowsPath(self.path, self.name))


@dataclass
class NeosObject(NeosRecord):
    assetUri: str
    lastModifyingMachineId: str
    ownerName: str
    tags: List[str]
    creationTime: datetime

@dataclass
class NeosWorld(NeosRecord):
    pass

@dataclass
class NeosTexture(NeosRecord):
    pass

@dataclass
class NeosAudio(NeosRecord):
    pass


recordTypeMapping = {
    RecordType.DIRECTORY: NeosDirectory,
    RecordType.LINK: NeosLink,
    RecordType.OBJECT: NeosObject,
    RecordType.WORLD: NeosWorld,
    RecordType.TEXTURE: NeosTexture,
    RecordType.AUDIO: NeosAudio,
}


@dataclass
class LoginDetails:
    """
    the login details for neos. SecretMachineId can be generated by neos.secrets
    """

    ownerId: Optional[str] = None
    username: Optional[str] = None
    email: Optional[str] = None
    password: Optional[str] = None
    secretMachineId: str = field(default_factory=generate)

    def __post_init__(self):
        if not self.ownerId and not self.username and not self.email:
            raise NeosException(
                'Either an ownerId, an username or an email is needed')
        if not self.password:
            raise NeosException('A password is needed')


@dataclass
class ProfileData:
    iconUrl: Optional[str]
    tokenOutOut: Optional[List[str]]


@dataclass
class CreditData:
    KFC: float
    NCR: float
    CDFT: float


@dataclass
class PatreonData:
    isPatreonSupporter: bool
    patreonId: Optional[str]
    lastPatreonPledgeCents: int
    lastTotalCents: int
    #lastTotalUnits: int
    minimumTotalUnits: int
    externalCents: int
    lastExternalCents: int
    hasSupported: bool
    lastIsAnorak: bool
    priorityIssue: int
    lastPlusActivationTime: datetime
    lastActivationTime: datetime
    lastPlusPledgeAmount: int
    lastPaidPledgeAmount: int
    accountName: str
    currentAccountType: int
    currentAccountCents: int
    pledgedAccountType: int


@dataclass
class NeosUser:
    id: str
    username: str
    normalizedUsername: str
    email: Optional[str]
    registrationDate: datetime
    isVerified: bool
    quotaBytes: Optional[int]
    isLocked: bool
    accountBanExpiration: Optional[datetime]
    publicBanExpiration: Optional[datetime]
    spectatorBanExpiration: Optional[datetime]
    muteBanExpiration: Optional[datetime]
    usedBytes: Optional[int]
    profile: Optional[ProfileData]
    credits: Optional[CreditData]
    NCRdepositAddress: Optional[str]
    patreonData: Optional[PatreonData]
    tags: Optional[List[str]] = field(default_factory=list)


class OnlineStatus(Enum):
    ONLINE = "Online"
    AWAY = "Away"
    BUSY = "Busy"
    OFFLINE = "Offline"


@dataclass
class UserStatusData:
    onlineStatus: OnlineStatus
    lastStatusChange: datetime
    currentSessionAccessLevel: int  # TODO: Find Enum Values
    currentSessionHidden: bool
    currentHosting: bool
    compatibilityHash: Optional[str]
    neosVersion: Optional[str]
    publicRSAKey: Optional[dict]  # investigate usefulness
    latestMessageTime: Optional[datetime]


onlineStatusMapping = {
    OnlineStatus.ONLINE: "Online",
    OnlineStatus.AWAY: "Away",
    OnlineStatus.BUSY: "Busy",
    OnlineStatus.OFFLINE: "Offline",
}


@dataclass
class NeosFriend:
    id: str
    friendUsername: str
    friendStatus: str  # TODO: find enum values
    isAccepted: bool
    userStatus: UserStatusData
    profile: Optional[ProfileData]
    latestMessageTime: datetime
